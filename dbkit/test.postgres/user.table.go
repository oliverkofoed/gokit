package dbkit_tests

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/lib/pq"
	"github.com/oliverkofoed/gokit/logkit"
	"github.com/satori/go.uuid"
	"strconv"
	"time"
)

// UsersTable is generated by dbkit
type UsersTable struct {
	BeforeUpdate func(context.Context, *User) error
	AfterUpdate func(context.Context, *User)
	BeforeInsert func(context.Context, *User) error
	AfterInsert func(context.Context, *User)
	driver usersDriver
}

// User represents a row in the Users table
type User struct {
	driver usersDriver
	ID      int64
	Birthdate      time.Time
	AnotherID      uuid.UUID
	Gender      int64
	Created      time.Time
	LastSeen      time.Time
	Interest      int64
	DisplayName      string
	Avatar      string
	Email      *string
	Keywords      []string
	FacebookUserID      *string
	ArbData      json.RawMessage
	
	loadID      int64
	loadBirthdate      time.Time
	loadAnotherID      uuid.UUID
	loadGender      int64
	loadCreated      time.Time
	loadLastSeen      time.Time
	loadInterest      int64
	loadDisplayName      string
	loadAvatar      string
	loadEmail      *string
	loadKeywords      []string
	loadFacebookUserID      *string
	loadArbData      json.RawMessage
	
	integerValue * 	  int64
	booleanvalue bool
	
}

// ExecuteP runs a raw comand against the database and panics on errors
func (t UsersTable) ExecuteP(ctx context.Context, command string, args ...interface{}) {
	err := t.driver.execute(ctx, command, args...)
	if err != nil {
		panic(panicWrap(err))
	}
}

// Execute runs a raw comand against the database
func (t UsersTable) Execute(ctx context.Context, command string, args ...interface{}) error{
	return t.driver.execute(ctx, command, args...)
}

// InsertP creates a record in the Users table and panics on errors
func (t UsersTable) InsertP(ctx context.Context, birthdate time.Time, anotherID uuid.UUID, gender int64, created time.Time, lastSeen time.Time, interest int64, displayName string, avatar string, email *string, keywords []string, facebookUserID *string, arbData json.RawMessage) *User {
	v, err := t.driver.insert(ctx, birthdate, anotherID, gender, created, lastSeen, interest, displayName, avatar, email, keywords, facebookUserID, arbData)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// Insert creates a record in the Users table
func (t UsersTable) Insert(ctx context.Context, birthdate time.Time, anotherID uuid.UUID, gender int64, created time.Time, lastSeen time.Time, interest int64, displayName string, avatar string, email *string, keywords []string, facebookUserID *string, arbData json.RawMessage) (*User, error) {
	return t.driver.insert(ctx, birthdate, anotherID, gender, created, lastSeen, interest, displayName, avatar, email, keywords, facebookUserID, arbData)
}

// LoadP a single record from the Users table based on the given query and panics on error
func (t UsersTable) LoadP(ctx context.Context, query string, args ...interface{}) *User {
	v, err := t.driver.load(ctx, query, args...)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// Load a single record from the Users table based on the given query
func (t UsersTable) Load(ctx context.Context, query string, args ...interface{}) (*User, error) {
	return t.driver.load(ctx, query, args...)
}

// DeleteP deletes records from the Users table based on the given query and panics on error
func (t UsersTable) DeleteP(ctx context.Context, query string, args ...interface{}) {
	err := t.driver.delete(ctx, query, args...)
	if err != nil {
		panic(panicWrap(err))
	}
}

// Delete deletes records from the Users table based on the given query
func (t UsersTable) Delete(ctx context.Context, query string, args ...interface{}) error {
	return t.driver.delete(ctx, query, args...)
}

// LoadByIDP loads a single record from the Users table based on the given values and panics on error
func (t UsersTable) LoadByIDP(ctx context.Context, id int64) *User {
	v, err := t.driver.loadByID(ctx, id)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// LoadByID loads a single record from the Users table based on the given values
func (t UsersTable) LoadByID(ctx context.Context, id int64) (*User, error) {
	return t.driver.loadByID(ctx, id)
}

// FindByID finds records the Users table based on the given values
func (t UsersTable) FindByID(id int64) *UserQuery {
	return t.driver.findByID(id)
}

// DeleteByID deletes records the Users table based on the given values and panics on error
func (t UsersTable) DeleteByIDP(ctx context.Context, id int64) {
	err := t.driver.deleteByID(ctx,id)
	if err != nil {
		panic(panicWrap(err))
	}
}

// DeleteByIDP deletes records the Users table based on the given values
func (t UsersTable) DeleteByID(ctx context.Context, id int64) error {
	return t.driver.deleteByID(ctx,id)
}

// LoadByAnotherIDP loads a single record from the Users table based on the given values and panics on error
func (t UsersTable) LoadByAnotherIDP(ctx context.Context, anotherID uuid.UUID) *User {
	v, err := t.driver.loadByAnotherID(ctx, anotherID)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// LoadByAnotherID loads a single record from the Users table based on the given values
func (t UsersTable) LoadByAnotherID(ctx context.Context, anotherID uuid.UUID) (*User, error) {
	return t.driver.loadByAnotherID(ctx, anotherID)
}

// FindByAnotherID finds records the Users table based on the given values
func (t UsersTable) FindByAnotherID(anotherID uuid.UUID) *UserQuery {
	return t.driver.findByAnotherID(anotherID)
}

// DeleteByAnotherID deletes records the Users table based on the given values and panics on error
func (t UsersTable) DeleteByAnotherIDP(ctx context.Context, anotherID uuid.UUID) {
	err := t.driver.deleteByAnotherID(ctx,anotherID)
	if err != nil {
		panic(panicWrap(err))
	}
}

// DeleteByAnotherIDP deletes records the Users table based on the given values
func (t UsersTable) DeleteByAnotherID(ctx context.Context, anotherID uuid.UUID) error {
	return t.driver.deleteByAnotherID(ctx,anotherID)
}

// LoadByAnotherIDAndGenderP loads a single record from the Users table based on the given values and panics on error
func (t UsersTable) LoadByAnotherIDAndGenderP(ctx context.Context, anotherID uuid.UUID, gender int64) *User {
	v, err := t.driver.loadByAnotherIDAndGender(ctx, anotherID, gender)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// LoadByAnotherIDAndGender loads a single record from the Users table based on the given values
func (t UsersTable) LoadByAnotherIDAndGender(ctx context.Context, anotherID uuid.UUID, gender int64) (*User, error) {
	return t.driver.loadByAnotherIDAndGender(ctx, anotherID, gender)
}

// FindByAnotherIDAndGender finds records the Users table based on the given values
func (t UsersTable) FindByAnotherIDAndGender(anotherID uuid.UUID, gender int64) *UserQuery {
	return t.driver.findByAnotherIDAndGender(anotherID, gender)
}

// DeleteByAnotherIDAndGender deletes records the Users table based on the given values and panics on error
func (t UsersTable) DeleteByAnotherIDAndGenderP(ctx context.Context, anotherID uuid.UUID, gender int64) {
	err := t.driver.deleteByAnotherIDAndGender(ctx,anotherID, gender)
	if err != nil {
		panic(panicWrap(err))
	}
}

// DeleteByAnotherIDAndGenderP deletes records the Users table based on the given values
func (t UsersTable) DeleteByAnotherIDAndGender(ctx context.Context, anotherID uuid.UUID, gender int64) error {
	return t.driver.deleteByAnotherIDAndGender(ctx,anotherID, gender)
}

// LoadByEmailP loads a single record from the Users table based on the given values and panics on error
func (t UsersTable) LoadByEmailP(ctx context.Context, email *string) *User {
	v, err := t.driver.loadByEmail(ctx, email)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// LoadByEmail loads a single record from the Users table based on the given values
func (t UsersTable) LoadByEmail(ctx context.Context, email *string) (*User, error) {
	return t.driver.loadByEmail(ctx, email)
}

// FindByEmail finds records the Users table based on the given values
func (t UsersTable) FindByEmail(email *string) *UserQuery {
	return t.driver.findByEmail(email)
}

// DeleteByEmail deletes records the Users table based on the given values and panics on error
func (t UsersTable) DeleteByEmailP(ctx context.Context, email *string) {
	err := t.driver.deleteByEmail(ctx,email)
	if err != nil {
		panic(panicWrap(err))
	}
}

// DeleteByEmailP deletes records the Users table based on the given values
func (t UsersTable) DeleteByEmail(ctx context.Context, email *string) error {
	return t.driver.deleteByEmail(ctx,email)
}

// LoadByFacebookUserIDP loads a single record from the Users table based on the given values and panics on error
func (t UsersTable) LoadByFacebookUserIDP(ctx context.Context, facebookUserID *string) *User {
	v, err := t.driver.loadByFacebookUserID(ctx, facebookUserID)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// LoadByFacebookUserID loads a single record from the Users table based on the given values
func (t UsersTable) LoadByFacebookUserID(ctx context.Context, facebookUserID *string) (*User, error) {
	return t.driver.loadByFacebookUserID(ctx, facebookUserID)
}

// FindByFacebookUserID finds records the Users table based on the given values
func (t UsersTable) FindByFacebookUserID(facebookUserID *string) *UserQuery {
	return t.driver.findByFacebookUserID(facebookUserID)
}

// DeleteByFacebookUserID deletes records the Users table based on the given values and panics on error
func (t UsersTable) DeleteByFacebookUserIDP(ctx context.Context, facebookUserID *string) {
	err := t.driver.deleteByFacebookUserID(ctx,facebookUserID)
	if err != nil {
		panic(panicWrap(err))
	}
}

// DeleteByFacebookUserIDP deletes records the Users table based on the given values
func (t UsersTable) DeleteByFacebookUserID(ctx context.Context, facebookUserID *string) error {
	return t.driver.deleteByFacebookUserID(ctx,facebookUserID)
}

// LoadByFacebookUserIDAndAvatarP loads a single record from the Users table based on the given values and panics on error
func (t UsersTable) LoadByFacebookUserIDAndAvatarP(ctx context.Context, facebookUserID *string, avatar string) *User {
	v, err := t.driver.loadByFacebookUserIDAndAvatar(ctx, facebookUserID, avatar)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// LoadByFacebookUserIDAndAvatar loads a single record from the Users table based on the given values
func (t UsersTable) LoadByFacebookUserIDAndAvatar(ctx context.Context, facebookUserID *string, avatar string) (*User, error) {
	return t.driver.loadByFacebookUserIDAndAvatar(ctx, facebookUserID, avatar)
}

// FindByFacebookUserIDAndAvatar finds records the Users table based on the given values
func (t UsersTable) FindByFacebookUserIDAndAvatar(facebookUserID *string, avatar string) *UserQuery {
	return t.driver.findByFacebookUserIDAndAvatar(facebookUserID, avatar)
}

// DeleteByFacebookUserIDAndAvatar deletes records the Users table based on the given values and panics on error
func (t UsersTable) DeleteByFacebookUserIDAndAvatarP(ctx context.Context, facebookUserID *string, avatar string) {
	err := t.driver.deleteByFacebookUserIDAndAvatar(ctx,facebookUserID, avatar)
	if err != nil {
		panic(panicWrap(err))
	}
}

// DeleteByFacebookUserIDAndAvatarP deletes records the Users table based on the given values
func (t UsersTable) DeleteByFacebookUserIDAndAvatar(ctx context.Context, facebookUserID *string, avatar string) error {
	return t.driver.deleteByFacebookUserIDAndAvatar(ctx,facebookUserID, avatar)
}

// LoadByAvatarP loads a single record from the Users table based on the given values and panics on error
func (t UsersTable) LoadByAvatarP(ctx context.Context, avatar string) *User {
	v, err := t.driver.loadByAvatar(ctx, avatar)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// LoadByAvatar loads a single record from the Users table based on the given values
func (t UsersTable) LoadByAvatar(ctx context.Context, avatar string) (*User, error) {
	return t.driver.loadByAvatar(ctx, avatar)
}

// FindByAvatar finds records the Users table based on the given values
func (t UsersTable) FindByAvatar(avatar string) *UserQuery {
	return t.driver.findByAvatar(avatar)
}

// DeleteByAvatar deletes records the Users table based on the given values and panics on error
func (t UsersTable) DeleteByAvatarP(ctx context.Context, avatar string) {
	err := t.driver.deleteByAvatar(ctx,avatar)
	if err != nil {
		panic(panicWrap(err))
	}
}

// DeleteByAvatarP deletes records the Users table based on the given values
func (t UsersTable) DeleteByAvatar(ctx context.Context, avatar string) error {
	return t.driver.deleteByAvatar(ctx,avatar)
}

// LoadByCreatedP loads a single record from the Users table based on the given values and panics on error
func (t UsersTable) LoadByCreatedP(ctx context.Context, created time.Time) *User {
	v, err := t.driver.loadByCreated(ctx, created)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// LoadByCreated loads a single record from the Users table based on the given values
func (t UsersTable) LoadByCreated(ctx context.Context, created time.Time) (*User, error) {
	return t.driver.loadByCreated(ctx, created)
}

// FindByCreated finds records the Users table based on the given values
func (t UsersTable) FindByCreated(created time.Time) *UserQuery {
	return t.driver.findByCreated(created)
}

// DeleteByCreated deletes records the Users table based on the given values and panics on error
func (t UsersTable) DeleteByCreatedP(ctx context.Context, created time.Time) {
	err := t.driver.deleteByCreated(ctx,created)
	if err != nil {
		panic(panicWrap(err))
	}
}

// DeleteByCreatedP deletes records the Users table based on the given values
func (t UsersTable) DeleteByCreated(ctx context.Context, created time.Time) error {
	return t.driver.deleteByCreated(ctx,created)
}

// LoadByCreatedAndGenderP loads a single record from the Users table based on the given values and panics on error
func (t UsersTable) LoadByCreatedAndGenderP(ctx context.Context, created time.Time, gender int64) *User {
	v, err := t.driver.loadByCreatedAndGender(ctx, created, gender)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// LoadByCreatedAndGender loads a single record from the Users table based on the given values
func (t UsersTable) LoadByCreatedAndGender(ctx context.Context, created time.Time, gender int64) (*User, error) {
	return t.driver.loadByCreatedAndGender(ctx, created, gender)
}

// FindByCreatedAndGender finds records the Users table based on the given values
func (t UsersTable) FindByCreatedAndGender(created time.Time, gender int64) *UserQuery {
	return t.driver.findByCreatedAndGender(created, gender)
}

// DeleteByCreatedAndGender deletes records the Users table based on the given values and panics on error
func (t UsersTable) DeleteByCreatedAndGenderP(ctx context.Context, created time.Time, gender int64) {
	err := t.driver.deleteByCreatedAndGender(ctx,created, gender)
	if err != nil {
		panic(panicWrap(err))
	}
}

// DeleteByCreatedAndGenderP deletes records the Users table based on the given values
func (t UsersTable) DeleteByCreatedAndGender(ctx context.Context, created time.Time, gender int64) error {
	return t.driver.deleteByCreatedAndGender(ctx,created, gender)
}

// LoadByCreatedAndGenderAndBirthdateP loads a single record from the Users table based on the given values and panics on error
func (t UsersTable) LoadByCreatedAndGenderAndBirthdateP(ctx context.Context, created time.Time, gender int64, birthdate time.Time) *User {
	v, err := t.driver.loadByCreatedAndGenderAndBirthdate(ctx, created, gender, birthdate)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// LoadByCreatedAndGenderAndBirthdate loads a single record from the Users table based on the given values
func (t UsersTable) LoadByCreatedAndGenderAndBirthdate(ctx context.Context, created time.Time, gender int64, birthdate time.Time) (*User, error) {
	return t.driver.loadByCreatedAndGenderAndBirthdate(ctx, created, gender, birthdate)
}

// FindByCreatedAndGenderAndBirthdate finds records the Users table based on the given values
func (t UsersTable) FindByCreatedAndGenderAndBirthdate(created time.Time, gender int64, birthdate time.Time) *UserQuery {
	return t.driver.findByCreatedAndGenderAndBirthdate(created, gender, birthdate)
}

// DeleteByCreatedAndGenderAndBirthdate deletes records the Users table based on the given values and panics on error
func (t UsersTable) DeleteByCreatedAndGenderAndBirthdateP(ctx context.Context, created time.Time, gender int64, birthdate time.Time) {
	err := t.driver.deleteByCreatedAndGenderAndBirthdate(ctx,created, gender, birthdate)
	if err != nil {
		panic(panicWrap(err))
	}
}

// DeleteByCreatedAndGenderAndBirthdateP deletes records the Users table based on the given values
func (t UsersTable) DeleteByCreatedAndGenderAndBirthdate(ctx context.Context, created time.Time, gender int64, birthdate time.Time) error {
	return t.driver.deleteByCreatedAndGenderAndBirthdate(ctx,created, gender, birthdate)
}

// Query creates a query for records in the Users table by id
func (t UsersTable) Query() *UserQuery {
	return &UserQuery{driver: t.driver}
}

// SaveP saves any changes to the row and panics on error
func (i *User) SaveP(ctx context.Context) {
	err := i.driver.save(ctx,i)
	if err != nil {
		panic(panicWrap(err))
	}
}

// Save saves any changes to the row
func (i *User) Save(ctx context.Context) error {
	return i.driver.save(ctx,i)
}

// UserQuery is a modifiable query against the Users table
type UserQuery struct {
	driver usersDriver

	whereQuery string
	orderColumns []string
	orderDirection []int
	args       []interface{}
	limit      int
	offset     int
}

// Limit changes the limit of the UserQuery query to the given value
func (q *UserQuery) Limit(limit int) *UserQuery {
	q.limit = limit
	return q
}

// Offset changes the offset of the UserQuery query to the given value
func (q *UserQuery) Offset(offset int) *UserQuery {
	q.offset = offset
	return q
}

// SortAscendingBy adds an ascending sort column to the query
func (q *UserQuery) SortAscendingBy(column string) *UserQuery {
	q.orderColumns = append(q.orderColumns, column)
	q.orderDirection = append(q.orderDirection, 1)
	return q
}

// SortDescendingBy adds an descending sort column to the query
func (q *UserQuery) SortDescendingBy(column string) *UserQuery {
	q.orderColumns = append(q.orderColumns, column)
	q.orderDirection = append(q.orderDirection, -1)
	return q
}

// Where changes the where clause of the query
func (q *UserQuery) Where(where string, args ...interface{}) *UserQuery {
	if q.whereQuery != "" {
		panic(errors.New("Cannot set where clause when where clause already exists."))
	}
	q.whereQuery = where
	q.args = args //TODO: check if already have args, then add instead of set.
	return q
}

// FirstP returns the first item found by the query and panics on error
func (q *UserQuery) FirstP(ctx context.Context) *User {
	v, err := q.driver.queryFirst(ctx,q)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// First returns the first item found by the query
func (q *UserQuery) First(ctx context.Context) ( *User, error) {
	return q.driver.queryFirst(ctx,q)
}

// Count returns a the count of matched item 
func (q *UserQuery) Count(ctx context.Context) (int64, error) {
	return q.driver.queryCount(ctx,q)
}

// CountP returns a the count of matched item and panics on error
func (q *UserQuery) CountP(ctx context.Context) int64 {
	c, err := q.driver.queryCount(ctx,q)
	if err != nil {
		panic(panicWrap(err))
	}
	return c
}

// SliceP returns a slice with all the matched item (warning: can use lots of memory) and panics on error
func (q *UserQuery) SliceP(ctx context.Context,expectedSliceSize int) []*User {
	v, err := q.driver.querySlice(ctx,q, expectedSliceSize)
	if err != nil {
		panic(panicWrap(err))
	}
	return v
}

// Slice returns a slice with all the matched item (warning: can use lots of memory)
func (q *UserQuery) Slice(ctx context.Context,expectedSliceSize int) ([]*User, error) {
	return q.driver.querySlice(ctx,q, expectedSliceSize)
}

// EachP returns a slice with all the matched item (warning: can use lots of memory) and panics on error
func (q *UserQuery) EachP(ctx context.Context, reuseItem bool, action func(*User) error) {
	err := q.driver.queryEach(ctx, q, reuseItem, action)
	if err != nil {
		panic(panicWrap(err))
	}
}

// Each returns a slice with all the matched item (warning: can use lots of memory)
func (q *UserQuery) Each(ctx context.Context, reuseItem bool, action func(*User) error) error {
	return q.driver.queryEach(ctx, q, reuseItem, action)
}

type usersDriver interface {
	execute(ctx context.Context,query string, args ...interface{}) error
	insert(ctx context.Context,birthdate time.Time, anotherID uuid.UUID, gender int64, created time.Time, lastSeen time.Time, interest int64, displayName string, avatar string, email *string, keywords []string, facebookUserID *string, arbData json.RawMessage) (*User, error)
	load(ctx context.Context,query string, args ...interface{}) (*User, error)
	delete(ctx context.Context,query string, args ...interface{}) error
	save(ctx context.Context,user *User) error
	//scan(user *User, rows *sql.Rows) error
	queryCount(ctx context.Context,query *UserQuery) (int64, error)
	queryFirst(ctx context.Context,query *UserQuery) (*User, error)
	querySlice(ctx context.Context,query *UserQuery, expectedSliceSize int) ([]*User, error)
	queryEach(ctx context.Context,query *UserQuery, reuseItem bool, action func(*User) error) error
	loadByID(ctx context.Context,id int64) (*User, error)
	findByID(id int64) *UserQuery
	deleteByID(ctx context.Context,id int64) error
	loadByAnotherID(ctx context.Context,anotherID uuid.UUID) (*User, error)
	findByAnotherID(anotherID uuid.UUID) *UserQuery
	deleteByAnotherID(ctx context.Context,anotherID uuid.UUID) error
	loadByAnotherIDAndGender(ctx context.Context,anotherID uuid.UUID, gender int64) (*User, error)
	findByAnotherIDAndGender(anotherID uuid.UUID, gender int64) *UserQuery
	deleteByAnotherIDAndGender(ctx context.Context,anotherID uuid.UUID, gender int64) error
	loadByEmail(ctx context.Context,email *string) (*User, error)
	findByEmail(email *string) *UserQuery
	deleteByEmail(ctx context.Context,email *string) error
	loadByFacebookUserID(ctx context.Context,facebookUserID *string) (*User, error)
	findByFacebookUserID(facebookUserID *string) *UserQuery
	deleteByFacebookUserID(ctx context.Context,facebookUserID *string) error
	loadByFacebookUserIDAndAvatar(ctx context.Context,facebookUserID *string, avatar string) (*User, error)
	findByFacebookUserIDAndAvatar(facebookUserID *string, avatar string) *UserQuery
	deleteByFacebookUserIDAndAvatar(ctx context.Context,facebookUserID *string, avatar string) error
	loadByAvatar(ctx context.Context,avatar string) (*User, error)
	findByAvatar(avatar string) *UserQuery
	deleteByAvatar(ctx context.Context,avatar string) error
	loadByCreated(ctx context.Context,created time.Time) (*User, error)
	findByCreated(created time.Time) *UserQuery
	deleteByCreated(ctx context.Context,created time.Time) error
	loadByCreatedAndGender(ctx context.Context,created time.Time, gender int64) (*User, error)
	findByCreatedAndGender(created time.Time, gender int64) *UserQuery
	deleteByCreatedAndGender(ctx context.Context,created time.Time, gender int64) error
	loadByCreatedAndGenderAndBirthdate(ctx context.Context,created time.Time, gender int64, birthdate time.Time) (*User, error)
	findByCreatedAndGenderAndBirthdate(created time.Time, gender int64, birthdate time.Time) *UserQuery
	deleteByCreatedAndGenderAndBirthdate(ctx context.Context,created time.Time, gender int64, birthdate time.Time) error
}

// IsDirty returns true if any of the values the originally loaded values
func (i *User) IsDirty() bool {
	if i.ID != i.loadID {
		return true
	}
	if i.Birthdate != i.loadBirthdate {
		return true
	}
	if !bytes.Equal(i.AnotherID.Bytes(),i.loadAnotherID.Bytes()) {
		return true
	}
	if i.Gender != i.loadGender {
		return true
	}
	if i.Created != i.loadCreated {
		return true
	}
	if i.LastSeen != i.loadLastSeen {
		return true
	}
	if i.Interest != i.loadInterest {
		return true
	}
	if i.DisplayName != i.loadDisplayName {
		return true
	}
	if i.Avatar != i.loadAvatar {
		return true
	}
	if i.Email != i.loadEmail && !(i.Email != nil && i.loadEmail != nil && *i.Email == *i.loadEmail) {
		return true
	}
	if !equalStringArrays(i.Keywords,i.loadKeywords) {
		return true
	}
	if i.FacebookUserID != i.loadFacebookUserID && !(i.FacebookUserID != nil && i.loadFacebookUserID != nil && *i.FacebookUserID == *i.loadFacebookUserID) {
		return true
	}
	if !bytes.Equal(i.ArbData,i.loadArbData) {
		return true
	}
	
	return false
}

// IsDirtyID returns true if the ID value differs from the originally loaded value
func (i *User) IsDirtyID() bool {
	return i.ID != i.loadID
}

// IsDirtyBirthdate returns true if the Birthdate value differs from the originally loaded value
func (i *User) IsDirtyBirthdate() bool {
	return i.Birthdate != i.loadBirthdate
}

// IsDirtyAnotherID returns true if the AnotherID value differs from the originally loaded value
func (i *User) IsDirtyAnotherID() bool {
	return !bytes.Equal(i.AnotherID.Bytes(),i.loadAnotherID.Bytes())
}

// IsDirtyGender returns true if the Gender value differs from the originally loaded value
func (i *User) IsDirtyGender() bool {
	return i.Gender != i.loadGender
}

// IsDirtyCreated returns true if the Created value differs from the originally loaded value
func (i *User) IsDirtyCreated() bool {
	return i.Created != i.loadCreated
}

// IsDirtyLastSeen returns true if the LastSeen value differs from the originally loaded value
func (i *User) IsDirtyLastSeen() bool {
	return i.LastSeen != i.loadLastSeen
}

// IsDirtyInterest returns true if the Interest value differs from the originally loaded value
func (i *User) IsDirtyInterest() bool {
	return i.Interest != i.loadInterest
}

// IsDirtyDisplayName returns true if the DisplayName value differs from the originally loaded value
func (i *User) IsDirtyDisplayName() bool {
	return i.DisplayName != i.loadDisplayName
}

// IsDirtyAvatar returns true if the Avatar value differs from the originally loaded value
func (i *User) IsDirtyAvatar() bool {
	return i.Avatar != i.loadAvatar
}

// IsDirtyEmail returns true if the Email value differs from the originally loaded value
func (i *User) IsDirtyEmail() bool {
	return i.Email != i.loadEmail && !(i.Email != nil && i.loadEmail != nil && *i.Email == *i.loadEmail)
}

// IsDirtyKeywords returns true if the Keywords value differs from the originally loaded value
func (i *User) IsDirtyKeywords() bool {
	return !equalStringArrays(i.Keywords,i.loadKeywords)
}

// IsDirtyFacebookUserID returns true if the FacebookUserID value differs from the originally loaded value
func (i *User) IsDirtyFacebookUserID() bool {
	return i.FacebookUserID != i.loadFacebookUserID && !(i.FacebookUserID != nil && i.loadFacebookUserID != nil && *i.FacebookUserID == *i.loadFacebookUserID)
}

// IsDirtyArbData returns true if the ArbData value differs from the originally loaded value
func (i *User) IsDirtyArbData() bool {
	return !bytes.Equal(i.ArbData,i.loadArbData)
}



// -------- postgres --------

type usersPostgresDriver struct {
	table *UsersTable
	db *sql.DB
}

func (d *usersPostgresDriver) execute(ctx context.Context, query string, args ...interface{}) error {
	if ctx == nil {
		ctx = context.Background()
	}
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",query))
	defer done()

	_, err := d.db.ExecContext(ctx,query,args...);
	return err
}

func (d *usersPostgresDriver) insert(ctx context.Context, birthdate time.Time, anotherID uuid.UUID, gender int64, created time.Time, lastSeen time.Time, interest int64, displayName string, avatar string, email *string, keywords []string, facebookUserID *string, arbData json.RawMessage) (*User, error) {
	if ctx == nil {
		ctx = context.Background()
	}

	item := User{
		driver:      d,
		Birthdate:      birthdate,
		AnotherID:      anotherID,
		Gender:      gender,
		Created:      created,
		LastSeen:      lastSeen,
		Interest:      interest,
		DisplayName:      displayName,
		Avatar:      avatar,
		Email:      email,
		Keywords:      keywords,
		FacebookUserID:      facebookUserID,
		ArbData:      arbData,
		
		loadBirthdate:      birthdate,
		loadAnotherID:      anotherID,
		loadGender:      gender,
		loadCreated:      created,
		loadLastSeen:      lastSeen,
		loadInterest:      interest,
		loadDisplayName:      displayName,
		loadAvatar:      avatar,
		loadEmail:      email,
		loadKeywords:      keywords,
		loadFacebookUserID:      facebookUserID,
		loadArbData:      arbData,
		
	}

	if d.table.BeforeInsert != nil {
		err := d.table.BeforeInsert(ctx, &item)
		if err != nil {
			return nil, fmt.Errorf("BeforeInsert error: %v", err)
		}
	}

	
	sql := "insert into Users(birthdate, another_id, gender, created, last_seen, interest, display_name, avatar, email, keywords, facebook_user_id, arb_data) values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) returning id"
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()
	var newID int64
	err := d.db.QueryRowContext(ctx,sql, birthdate, anotherID, gender, created, lastSeen, interest, displayName, avatar, email, pq.Array(keywords), facebookUserID, arbData).Scan(&newID)
	
	if err != nil {
		return nil, err
	}

	
	item.ID = newID
	item.loadID = newID
	

	if d.table.AfterInsert != nil {
		d.table.AfterInsert(ctx, &item)
	}

	return &item, nil
}

func (d *usersPostgresDriver) load(ctx context.Context, query string, args ...interface{}) (*User, error) {
	if ctx == nil {
		ctx = context.Background()
	}
	sql := "SELECT id, birthdate, another_id, gender, created, last_seen, interest, display_name, avatar, email, keywords, facebook_user_id, arb_data from Users where "+query
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()
	rows, err := d.db.QueryContext(ctx,sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var item *User
	if rows.Next() {
		item = &User{}
		if err := d.scan(item, rows); err != nil {
			return nil, err
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return item, nil
}

func (d *usersPostgresDriver) delete(ctx context.Context, query string, args ...interface{}) error {
	if ctx == nil {
		ctx = context.Background()
	}
	sql := "delete from Users where "+query
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()

	_, err := d.db.ExecContext(ctx,sql,args...);
	return err
}

func (d *usersPostgresDriver) scan(item *User, rows *sql.Rows) error {
	err := rows.Scan(&item.ID, &item.Birthdate, &item.AnotherID, &item.Gender, &item.Created, &item.LastSeen, &item.Interest, &item.DisplayName, &item.Avatar, &item.Email, pq.Array(&item.Keywords), &item.FacebookUserID, &item.ArbData)
	if err != nil {
		return err
	}
	item.driver = d
	item.loadID = item.ID
	item.loadBirthdate = item.Birthdate
	item.loadAnotherID = item.AnotherID
	item.loadGender = item.Gender
	item.loadCreated = item.Created
	item.loadLastSeen = item.LastSeen
	item.loadInterest = item.Interest
	item.loadDisplayName = item.DisplayName
	item.loadAvatar = item.Avatar
	item.loadEmail = item.Email
	item.loadKeywords = item.Keywords
	item.loadFacebookUserID = item.FacebookUserID
	item.loadArbData = item.ArbData
	
	return nil
}

func (d *usersPostgresDriver) save(ctx context.Context, item *User) error {
	if d.table.BeforeUpdate != nil {
		err := d.table.BeforeUpdate(ctx, item)
		if err != nil {
			return fmt.Errorf("BeforeSave error: %v", err)
		}
	}

	sql, args := getSaveUserSQL(item,1)

	// nothing changed
	if sql == "" {
		return nil
	}

	// execute
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()

	if _, err := d.db.Exec(sql, args...); err != nil {
		return logkit.Error(ctx, "SQL Error", logkit.String("sql",sql), logkit.Err(err))
	}

	if d.table.AfterUpdate != nil {
		d.table.AfterUpdate(ctx, item)
	}

	// reset load variables.
	item.resetLoadVars()

	return nil
}

func getSaveUserSQL(item *User, argOffset int) (string, []interface{}) {
	var sb bytes.Buffer
	sb.WriteString("update Users set ")
	args := make([]interface{}, 0, 13 )

	
	if item.ID != item.loadID {
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("id=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.ID )
	}
	
	if item.Birthdate != item.loadBirthdate {
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("birthdate=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.Birthdate )
	}
	
	if !bytes.Equal(item.AnotherID.Bytes(),item.loadAnotherID.Bytes()) {
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("another_id=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.AnotherID )
	}
	
	if item.Gender != item.loadGender {
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("gender=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.Gender )
	}
	
	if item.Created != item.loadCreated {
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("created=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.Created )
	}
	
	if item.LastSeen != item.loadLastSeen {
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("last_seen=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.LastSeen )
	}
	
	if item.Interest != item.loadInterest {
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("interest=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.Interest )
	}
	
	if item.DisplayName != item.loadDisplayName {
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("display_name=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.DisplayName )
	}
	
	if item.Avatar != item.loadAvatar {
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("avatar=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.Avatar )
	}
	
	if item.Email != item.loadEmail && !(item.Email != nil && item.loadEmail != nil && *item.Email == *item.loadEmail) {
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("email=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.Email )
	}
	
	if !equalStringArrays(item.Keywords,item.loadKeywords) {
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("keywords=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, pq.Array(item.Keywords ))
	}
	
	if item.FacebookUserID != item.loadFacebookUserID && !(item.FacebookUserID != nil && item.loadFacebookUserID != nil && *item.FacebookUserID == *item.loadFacebookUserID) {
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("facebook_user_id=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.FacebookUserID )
	}
	
	if !bytes.Equal(item.ArbData,item.loadArbData) {
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString("arb_data=$")
		sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
		args = append(args, item.ArbData )
	}
	

	if len(args) == 0 {
		return "", args
	}

	// where clause
	sb.WriteString(" where")
	
	sb.WriteString(" id=$")
	sb.WriteString(strconv.FormatInt(int64(len(args)+argOffset), 10))
	args = append(args, item.ID)
	

	return sb.String(), args
}

func (i *User) resetLoadVars(){
	i.loadID = i.ID
	i.loadBirthdate = i.Birthdate
	i.loadAnotherID = i.AnotherID
	i.loadGender = i.Gender
	i.loadCreated = i.Created
	i.loadLastSeen = i.LastSeen
	i.loadInterest = i.Interest
	i.loadDisplayName = i.DisplayName
	i.loadAvatar = i.Avatar
	i.loadEmail = i.Email
	i.loadKeywords = i.Keywords
	i.loadFacebookUserID = i.FacebookUserID
	i.loadArbData = i.ArbData
	
}

func (d *usersPostgresDriver) queryCount(ctx context.Context, query *UserQuery) (int64, error) {
	var sb bytes.Buffer
	sb.WriteString("Select count(*) from Users")
	if query.whereQuery != "" {
		sb.WriteString(" WHERE ")
		sb.WriteString(query.whereQuery)
	}
	sql := sb.String()
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()
	rows, err := d.db.Query(sql, query.args...)
	if err != nil {
		return 0, err
	}
	defer rows.Close()

	count := int64(0)
	if rows.Next() {
		if err := rows.Scan(&count); err != nil {
			return 0, err
		}
	}
	if err := rows.Err(); err != nil {
		return 0, err
	}

	return count, nil
}

func (d *usersPostgresDriver) queryFirst(ctx context.Context, query *UserQuery) (*User, error) {
	sql := d.querySQL(query)
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()
	rows, err := d.db.Query(sql, query.args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var item *User
	if rows.Next() {
		item = &User{}
		if err := d.scan(item, rows); err != nil {
			return nil, err
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return item, nil
}

func (d *usersPostgresDriver) querySlice(ctx context.Context, query *UserQuery, expectedSliceSize int) ([]*User, error) {
	sql := d.querySQL(query)
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()

	rows, err := d.db.Query(sql, query.args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	result := make([]*User, 0, expectedSliceSize)
	for rows.Next() {
		item := &User{}
		if err := d.scan(item, rows); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return result, nil
}

func (d *usersPostgresDriver) queryEach(ctx context.Context, query *UserQuery, reuseItem bool, action func(*User) error) error {
	sql := d.querySQL(query)
	ctx, done := logkit.Operation(ctx,"pg.sql", logkit.String("sql",sql))
	defer done()

	rows, err := d.db.Query(sql, query.args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	var item *User
	for rows.Next() {
		if item == nil || !reuseItem {
			item = &User{}
		}

		if err := d.scan(item, rows); err != nil {
			return err
		}

		if err := action(item); err != nil {
			return err
		}
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

func (d *usersPostgresDriver) querySQL(query *UserQuery) string {
	var sb bytes.Buffer

	sb.WriteString("Select id, birthdate, another_id, gender, created, last_seen, interest, display_name, avatar, email, keywords, facebook_user_id, arb_data from Users")

	if query.whereQuery != "" {
		sb.WriteString(" WHERE ")
		sb.WriteString(query.whereQuery)
	}
	if len(query.orderColumns) > 0 {
		sb.WriteString(" ORDER BY ")
		for i, col := range query.orderColumns {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(col)
			if query.orderDirection[i] == 1 {
				sb.WriteString(" ASC")
			}else{
				sb.WriteString(" DESC")
			}
		}

	}
	if query.limit > 0 {
		sb.WriteString(" LIMIT ")
		sb.WriteString(strconv.FormatInt(int64(query.limit), 10))
	}
	if query.offset > 0 {
		sb.WriteString(" OFFSET ")
		sb.WriteString(strconv.FormatInt(int64(query.offset), 10))
	}

	return sb.String()
}


func (d *usersPostgresDriver) loadByID(ctx context.Context, id int64) (*User, error) {
	return d.load(ctx,"id=$1", id)
}

func (d *usersPostgresDriver) findByID(id int64) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("id=$1", id)
	return q
}

func (d *usersPostgresDriver) deleteByID(ctx context.Context, id int64) error {
	return d.delete(ctx,"id=$1", id)
}

func (d *usersPostgresDriver) loadByAnotherID(ctx context.Context, anotherID uuid.UUID) (*User, error) {
	return d.load(ctx,"another_id=$1", anotherID)
}

func (d *usersPostgresDriver) findByAnotherID(anotherID uuid.UUID) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("another_id=$1", anotherID)
	return q
}

func (d *usersPostgresDriver) deleteByAnotherID(ctx context.Context, anotherID uuid.UUID) error {
	return d.delete(ctx,"another_id=$1", anotherID)
}

func (d *usersPostgresDriver) loadByAnotherIDAndGender(ctx context.Context, anotherID uuid.UUID, gender int64) (*User, error) {
	return d.load(ctx,"another_id=$1 and gender=$2", anotherID, gender)
}

func (d *usersPostgresDriver) findByAnotherIDAndGender(anotherID uuid.UUID, gender int64) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("another_id=$1 and gender=$2", anotherID, gender)
	return q
}

func (d *usersPostgresDriver) deleteByAnotherIDAndGender(ctx context.Context, anotherID uuid.UUID, gender int64) error {
	return d.delete(ctx,"another_id=$1 and gender=$2", anotherID, gender)
}

func (d *usersPostgresDriver) loadByEmail(ctx context.Context, email *string) (*User, error) {
	return d.load(ctx,"email=$1", email)
}

func (d *usersPostgresDriver) findByEmail(email *string) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("email=$1", email)
	return q
}

func (d *usersPostgresDriver) deleteByEmail(ctx context.Context, email *string) error {
	return d.delete(ctx,"email=$1", email)
}

func (d *usersPostgresDriver) loadByFacebookUserID(ctx context.Context, facebookUserID *string) (*User, error) {
	return d.load(ctx,"facebook_user_id=$1", facebookUserID)
}

func (d *usersPostgresDriver) findByFacebookUserID(facebookUserID *string) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("facebook_user_id=$1", facebookUserID)
	return q
}

func (d *usersPostgresDriver) deleteByFacebookUserID(ctx context.Context, facebookUserID *string) error {
	return d.delete(ctx,"facebook_user_id=$1", facebookUserID)
}

func (d *usersPostgresDriver) loadByFacebookUserIDAndAvatar(ctx context.Context, facebookUserID *string, avatar string) (*User, error) {
	return d.load(ctx,"facebook_user_id=$1 and avatar=$2", facebookUserID, avatar)
}

func (d *usersPostgresDriver) findByFacebookUserIDAndAvatar(facebookUserID *string, avatar string) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("facebook_user_id=$1 and avatar=$2", facebookUserID, avatar)
	return q
}

func (d *usersPostgresDriver) deleteByFacebookUserIDAndAvatar(ctx context.Context, facebookUserID *string, avatar string) error {
	return d.delete(ctx,"facebook_user_id=$1 and avatar=$2", facebookUserID, avatar)
}

func (d *usersPostgresDriver) loadByAvatar(ctx context.Context, avatar string) (*User, error) {
	return d.load(ctx,"avatar=$1", avatar)
}

func (d *usersPostgresDriver) findByAvatar(avatar string) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("avatar=$1", avatar)
	return q
}

func (d *usersPostgresDriver) deleteByAvatar(ctx context.Context, avatar string) error {
	return d.delete(ctx,"avatar=$1", avatar)
}

func (d *usersPostgresDriver) loadByCreated(ctx context.Context, created time.Time) (*User, error) {
	return d.load(ctx,"created=$1", created)
}

func (d *usersPostgresDriver) findByCreated(created time.Time) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("created=$1", created)
	return q
}

func (d *usersPostgresDriver) deleteByCreated(ctx context.Context, created time.Time) error {
	return d.delete(ctx,"created=$1", created)
}

func (d *usersPostgresDriver) loadByCreatedAndGender(ctx context.Context, created time.Time, gender int64) (*User, error) {
	return d.load(ctx,"created=$1 and gender=$2", created, gender)
}

func (d *usersPostgresDriver) findByCreatedAndGender(created time.Time, gender int64) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("created=$1 and gender=$2", created, gender)
	return q
}

func (d *usersPostgresDriver) deleteByCreatedAndGender(ctx context.Context, created time.Time, gender int64) error {
	return d.delete(ctx,"created=$1 and gender=$2", created, gender)
}

func (d *usersPostgresDriver) loadByCreatedAndGenderAndBirthdate(ctx context.Context, created time.Time, gender int64, birthdate time.Time) (*User, error) {
	return d.load(ctx,"created=$1 and gender=$2 and birthdate=$3", created, gender, birthdate)
}

func (d *usersPostgresDriver) findByCreatedAndGenderAndBirthdate(created time.Time, gender int64, birthdate time.Time) *UserQuery {
	q :=&UserQuery{driver: d}
	q.Where("created=$1 and gender=$2 and birthdate=$3", created, gender, birthdate)
	return q
}

func (d *usersPostgresDriver) deleteByCreatedAndGenderAndBirthdate(ctx context.Context, created time.Time, gender int64, birthdate time.Time) error {
	return d.delete(ctx,"created=$1 and gender=$2 and birthdate=$3", created, gender, birthdate)
}

