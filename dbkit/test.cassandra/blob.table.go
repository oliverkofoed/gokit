package dbkit_tests

import (
	"bytes"
	"context"
	"github.com/gocql/gocql"
	"github.com/oliverkofoed/gokit/logkit"
	"strconv"
)

// BlobsTable is generated by dbkit
type BlobsTable struct {
	driver blobsDriver
}

// Insert creates a record in the Blobs table
func (t BlobsTable) Insert(ctx context.Context, id []byte, _type int32, data []byte) (*Blob, error) {
	return t.driver.insert(ctx, id, _type, data)
}

// Load a single record from the Blobs table based on the given query
func (t BlobsTable) Load(ctx context.Context, query string, args ...interface{}) (*Blob, error) {
	return t.driver.load(ctx, query, args...)
}

// Delete deletes records from the Blobs table based on the given query
func (t BlobsTable) Delete(ctx context.Context, query string, args ...interface{}) error {
	return t.driver.delete(ctx, query, args...)
}

// LoadByID loads a single record from the Blobs table based on the given values
func (t BlobsTable) LoadByID(ctx context.Context, id []byte) (*Blob, error) {
	return t.driver.loadByID(ctx, id)
}

// FindByID finds records the Blobs table based on the given values
func (t BlobsTable) FindByID(id []byte) *BlobQuery {
	return t.driver.findByID(id)
}

// DeleteByID deletes records the Blobs table based on the given values
func (t BlobsTable) DeleteByID(ctx context.Context, id []byte) error {
	return t.driver.deleteByID(ctx,id)
}

// LoadByIDAndType loads a single record from the Blobs table based on the given values
func (t BlobsTable) LoadByIDAndType(ctx context.Context, id []byte, _type int32) (*Blob, error) {
	return t.driver.loadByIDAndType(ctx, id, _type)
}

// FindByIDAndType finds records the Blobs table based on the given values
func (t BlobsTable) FindByIDAndType(id []byte, _type int32) *BlobQuery {
	return t.driver.findByIDAndType(id, _type)
}

// DeleteByIDAndType deletes records the Blobs table based on the given values
func (t BlobsTable) DeleteByIDAndType(ctx context.Context, id []byte, _type int32) error {
	return t.driver.deleteByIDAndType(ctx,id, _type)
}

// Query creates a query for records in the Blobs table by id
func (t BlobsTable) Query() *BlobQuery {
	return &BlobQuery{driver: t.driver}
}

// Blob represents a row in the Blobs table
type Blob struct {
	driver blobsDriver
	ID      []byte
	Type      int32
	Data      []byte
	
	loadID      []byte
	loadType      int32
	loadData      []byte
	
}

// Save saves any changes to the row
func (i *Blob) Save(ctx context.Context) error {
	return i.driver.save(ctx,i)
}

// BlobQuery is a modifiable query against the Blobs table
type BlobQuery struct {
	driver blobsDriver

	whereQuery string
	orderColumns []string
	orderDirection []int
	args       []interface{}
	limit      int
}

// Limit changes the limit of the BlobQuery query to the given value
func (q *BlobQuery) Limit(limit int) *BlobQuery {
	q.limit = limit
	return q
}

// SortAscendingBy adds an ascending sort column to the query
func (q *BlobQuery) SortAscendingBy(column string) *BlobQuery {
	q.orderColumns = append(q.orderColumns, column)
	q.orderDirection = append(q.orderDirection, 1)
	return q
}

// SortDescendingBy adds an descending sort column to the query
func (q *BlobQuery) SortDescendingBy(column string) *BlobQuery {
	q.orderColumns = append(q.orderColumns, column)
	q.orderDirection = append(q.orderDirection, -1)
	return q
}

// Where changes the where clause of the query
func (q *BlobQuery) Where(where string, args ...interface{}) *BlobQuery {
	q.whereQuery = where
	q.args = args //TODO: check if already have args, then add instead of set.
	return q
}

// First returns the first item found by the query
func (q *BlobQuery) First(ctx context.Context) ( *Blob, error) {
	return q.driver.queryFirst(ctx,q)
}

// Slice returns a slice with all the matched item (warning: can use lots of memory)
func (q *BlobQuery) Slice(ctx context.Context,expectedSliceSize int) ([]*Blob, error) {
	return q.driver.querySlice(ctx,q, expectedSliceSize)
}

// Each returns a slice with all the matched item (warning: can use lots of memory)
func (q *BlobQuery) Each(ctx context.Context, reuseItem bool, action func(*Blob) error) error {
	return q.driver.queryEach(ctx, q, reuseItem, action)
}

type blobsDriver interface {
	insert(ctx context.Context,id []byte, _type int32, data []byte) (*Blob, error)
	load(ctx context.Context,query string, args ...interface{}) (*Blob, error)
	delete(ctx context.Context,query string, args ...interface{}) error
	save(ctx context.Context,blob *Blob) error
	//scan(blob *Blob, rows *sql.Rows) error
	queryFirst(ctx context.Context,query *BlobQuery) (*Blob, error)
	querySlice(ctx context.Context,query *BlobQuery, expectedSliceSize int) ([]*Blob, error)
	queryEach(ctx context.Context,query *BlobQuery, reuseItem bool, action func(*Blob) error) error
	loadByID(ctx context.Context,id []byte) (*Blob, error)
	findByID(id []byte) *BlobQuery
	deleteByID(ctx context.Context,id []byte) error
	loadByIDAndType(ctx context.Context,id []byte, _type int32) (*Blob, error)
	findByIDAndType(id []byte, _type int32) *BlobQuery
	deleteByIDAndType(ctx context.Context,id []byte, _type int32) error
}


// -------- cassandra --------

type blobsCassandraDriver struct {
	db *gocql.Session
}

func (d *blobsCassandraDriver) insert(ctx context.Context, id []byte, _type int32, data []byte) (*Blob, error) {
	return d.insertTTL(ctx, 0, id, _type, data)
}

// InsertTTL creates a record in the Cassandra Blobs table with the given TTL value
func (t BlobsTable) InsertTTL(ctx context.Context, ttl int64, id []byte, _type int32, data []byte) (*Blob, error) {
	return t.driver.(*blobsCassandraDriver).insertTTL(ctx, ttl, id, _type, data)
}

func (d *blobsCassandraDriver) insertTTL(ctx context.Context, ttl int64, id []byte, _type int32, data []byte) (*Blob, error) {
	if ctx == nil {
		ctx = context.Background()
	}

	
	cql := "insert into Blobs(id, type, data) values (?, ?, ?)"
	if ttl > 0 {
		cql += " USING TTL " + strconv.FormatInt(ttl, 10)
	}
	args := []interface{}{  id, _type, data }
	ctx, done := logkit.Operation(ctx,"cassandra.cql", logkit.Stringer("cql",cqlStringer{cql:cql, args:args}))
	defer done()

	err := d.db.Query(cql, args...).Exec()
	
	if err != nil {
		return nil, logkit.Error(ctx, "CQL Error", logkit.Stringer("cql",cqlStringer{cql:cql, args:args}), logkit.Err(err))
	}

	return &Blob{
		driver:      d,
		
		ID:      id,
		Type:      _type,
		Data:      data,
		
		loadID:      id,
		loadType:      _type,
		loadData:      data,
		
	}, nil
	return nil, nil
}

func (d *blobsCassandraDriver) load(ctx context.Context, query string, args ...interface{}) (*Blob, error) {
	if ctx == nil {
		ctx = context.Background()
	}
	cql := "SELECT id, type, data from Blobs where "+query
	ctx, done := logkit.Operation(ctx,"cassandra.cql", logkit.Stringer("cql",cqlStringer{cql:cql, args:args}))
	defer done()

	item := &Blob{}
	if err := d.db.Query(cql, args...).Scan(&item.ID, &item.Type, &item.Data); err != nil {
		if err == gocql.ErrNotFound {
			return nil, nil
		}
		return nil, logkit.Error(ctx, "CQL Error", logkit.Stringer("cql",cqlStringer{cql:cql, args:args}), logkit.Err(err))
	}
	item.driver = d
	item.loadID = item.ID
	item.loadType = item.Type
	item.loadData = item.Data
	
	return item, nil
}

func (d *blobsCassandraDriver) delete(ctx context.Context, query string, args ...interface{}) error {
	if ctx == nil {
		ctx = context.Background()
	}
	cql := "delete from Blobs where "+query
	ctx, done := logkit.Operation(ctx,"cassandra.cql", logkit.Stringer("cql",cqlStringer{cql:cql, args:args}))
	defer done()

	if err := d.db.Query(cql, args...).Exec(); err != nil {
		return logkit.Error(ctx, "CQL Error", logkit.Stringer("cql",cqlStringer{cql:cql, args:args}), logkit.Err(err))
	}
	return nil
}


func cassandraScanBlob(d *blobsCassandraDriver, iter *gocql.Iter, item *Blob) bool {
	result := iter.Scan(&item.ID, &item.Type, &item.Data)
	item.driver = d
	item.loadID = item.ID
	item.loadType = item.Type
	item.loadData = item.Data
	
	return result
	/*err := rows.Scan()
	if err != nil {
		return err
	}
	return nil
	return nil
	*/
}

func (d *blobsCassandraDriver) save(ctx context.Context, item *Blob) error {
	cql, args := getSaveBlobCQL(item)
	
	// nothings changed
	if cql == "" {
		return nil
	}

	// execute
	ctx, done := logkit.Operation(ctx,"cassandra.cql", logkit.Stringer("cql",cqlStringer{cql:cql, args:args}))
	defer done()

	if err := d.db.Query(cql, args...).Exec(); err != nil {
		return logkit.Error(ctx, "CQL Error", logkit.Stringer("cql",cqlStringer{cql:cql, args:args}), logkit.Err(err))
	}

	// reset load variables.
	item.resetLoadVars()
	return nil
}

func getSaveBlobCQL(item *Blob) (string, []interface{}) {
	var sb bytes.Buffer
	sb.WriteString("update Blobs set ")
	args := make([]interface{}, 0, 3 )

	
	if !bytes.Equal(item.ID,item.loadID) { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		args = append(args, item.ID)
		sb.WriteString("id=?")
		//sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	}
	
	if item.Type != item.loadType { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		args = append(args, item.Type)
		sb.WriteString("type=?")
		//sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	}
	
	if !bytes.Equal(item.Data,item.loadData) { 
		if len(args) != 0 {
			sb.WriteString(", ")
		}
		args = append(args, item.Data)
		sb.WriteString("data=?")
		//sb.WriteString(strconv.FormatInt(int64(len(args)), 10))
	}
	

	if len(args) == 0 {
		return "", args
	}

	// where clause
	sb.WriteString(" where  id=?  and  type=?")
	
	args = append(args, item.ID)
	args = append(args, item.Type)

	return sb.String(), args
}

func (i *Blob) resetLoadVars(){
	i.loadID = i.ID
	i.loadType = i.Type
	i.loadData = i.Data
	
}

func (d *blobsCassandraDriver) queryFirst(ctx context.Context, query *BlobQuery) (*Blob, error) {
	cql := d.queryCQL(query)
	ctx, done := logkit.Operation(ctx,"cassandra.cql", logkit.Stringer("cql",cqlStringer{cql:cql, args:query.args}))
	defer done()

	item := &Blob{}
	if err := d.db.Query(cql, query.args...).Scan(&item.ID, &item.Type, &item.Data); err != nil {
		if err == gocql.ErrNotFound {
			return nil, nil
		}
		return nil, logkit.Error(ctx, "CQL Error", logkit.Stringer("cql",cqlStringer{cql:cql, args:query.args}), logkit.Err(err))
	}
	item.driver = d
	item.loadID = item.ID
	item.loadType = item.Type
	item.loadData = item.Data
	
	return item, nil
}

func (d *blobsCassandraDriver) querySlice(ctx context.Context, query *BlobQuery, expectedSliceSize int) ([]*Blob, error) {
	cql := d.queryCQL(query)
	ctx, done := logkit.Operation(ctx,"cassandra.cql", logkit.Stringer("cql",cqlStringer{cql:cql, args:query.args}))
	defer done()

	iter := d.db.Query(cql, query.args...).Iter()
	result := make([]*Blob, 0, expectedSliceSize)
	for {
		item := &Blob{}
		if iter.Scan(&item.ID, &item.Type, &item.Data) {
			item.driver = d
			item.loadID = item.ID
			item.loadType = item.Type
			item.loadData = item.Data
			
			result = append(result, item)
		}else{
			break
		}
	}
	if err := iter.Close(); err != nil {
		return nil, logkit.Error(ctx, "CQL Error", logkit.Stringer("cql",cqlStringer{cql:cql, args:query.args}), logkit.Err(err))
	}
	return result, nil
}

func (d *blobsCassandraDriver) queryEach(ctx context.Context, query *BlobQuery, reuseItem bool, action func(*Blob) error) error {
	cql := d.queryCQL(query)
	ctx, done := logkit.Operation(ctx,"cassandra.cql", logkit.Stringer("cql",cqlStringer{cql:cql, args:query.args}))
	defer done()

	iter := d.db.Query(cql, query.args...).Iter()
	var item *Blob
	for {
		if item == nil || !reuseItem {
			item = &Blob{}
			item.driver = d
		}

		if iter.Scan(&item.ID, &item.Type, &item.Data) {
			item.loadID = item.ID
			item.loadType = item.Type
			item.loadData = item.Data
			
			if err := action(item); err != nil {
				iter.Close(); 
				return err
			}
		}else{
			break
		}

	}
	if err := iter.Close(); err != nil {
		return  logkit.Error(ctx, "CQL Error", logkit.Stringer("cql",cqlStringer{cql:cql, args:query.args}), logkit.Err(err))
	}

	return nil
}

func (d *blobsCassandraDriver) queryCQL(query *BlobQuery) string {
	var sb bytes.Buffer

	sb.WriteString("Select id, type, data from Blobs")

	if query.whereQuery != "" {
		sb.WriteString(" WHERE ")
		sb.WriteString(query.whereQuery)
	}
	if len(query.orderColumns) > 0 {
		sb.WriteString(" ORDER BY ")
		for i, col := range query.orderColumns {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(col)
			if query.orderDirection[i] == 1 {
				sb.WriteString(" ASC")
			}else{
				sb.WriteString(" DESC")
			}
		}

	}
	if query.limit > 0 {
		sb.WriteString(" LIMIT ")
		sb.WriteString(strconv.FormatInt(int64(query.limit), 10))
	}

	return sb.String()
}


func (d *blobsCassandraDriver) loadByID(ctx context.Context, id []byte) (*Blob, error) {
	return d.load(ctx,"id=?", id)
}

func (d *blobsCassandraDriver) findByID(id []byte) *BlobQuery {
	q :=&BlobQuery{driver: d}
	q.Where("id=?", id)
	return q
}

func (d *blobsCassandraDriver) deleteByID(ctx context.Context, id []byte) error {
	return d.delete(ctx,"id=?", id)
}

func (d *blobsCassandraDriver) loadByIDAndType(ctx context.Context, id []byte, _type int32) (*Blob, error) {
	return d.load(ctx,"id=? and type=?", id, _type)
}

func (d *blobsCassandraDriver) findByIDAndType(id []byte, _type int32) *BlobQuery {
	q :=&BlobQuery{driver: d}
	q.Where("id=? and type=?", id, _type)
	return q
}

func (d *blobsCassandraDriver) deleteByIDAndType(ctx context.Context, id []byte, _type int32) error {
	return d.delete(ctx,"id=? and type=?", id, _type)
}

